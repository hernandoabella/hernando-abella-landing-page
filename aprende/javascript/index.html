<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hernando Abella | Tutorial de JAVASCRIPT</title>
    <link rel="stylesheet" href="/css/styles.css">
    <link rel="stylesheet" href="./pagination.css">
    <link rel="stylesheet" href="./theme.css">
    <link rel="stylesheet" href="https://pro.fontawesome.com/releases/v5.10.0/css/all.css" integrity="sha384-AYmEC3Yw5cVb3ZcuHtOA93w35dYTsvhLPVnYs9eStHfGJvOvKxVfELGroGkvsg+p" crossorigin="anonymous"/>
</head>
<body>
    <div class="backbar">
        <a href="/aprende/"><i class="fas fa-arrow-left"></i></a>
        <span style="color: #fff; margin-left: 10px; font-family:'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif">Aprende HTML</span>
    </div>

    <div class="header">
        <div class="progress-container">
          <div class="progress-bar" id="myBar"></div>
        </div>  
      </div>
      

    <div class="flexStuff">
        
        <aside class="sideBar">
            
            <nav class="itemNav">
                <ul>
                    
                    <li>
                        <a href="#item1">Introducción</a>
                    </li>
                    <li>
                        <a href="#item2">Historia</a>
                    </li>
                    <li>
                        <a href="#item3">Vanilla JS</a>
                    </li>
                    <li>
                        <a href="#item4">Punto y coma</a>
                    </li>
                    <li>
                        <a href="#item5">Valores</a>
                    </li>
                    <li>
                        <a href="#item6">Variables</a>
                    </li>
                    <li>
                        <a href="#item7">Tipos</a>
                    </li>
                    <li>
                        <a href="#item8">Expresiones</a>
                    </li>
                    <li>
                        <a href="#item9">Operadores</a>
                    </li>
                    <li>
                        <a href="#item10">Reglas de precedencia</a>
                    </li>
                    <li>
                        <a href="#item11">Operadores de comparación</a>
                    </li>
                    <li>
                        <a href="#item12">Condicionales</a>
                    </li>
                    <li>
                        <a href="#item13">Arreglos</a>
                    </li>
                    <li>
                        <a href="#item14">Cadena de texto</a>
                    </li>
                    <li>
                        <a href="#item15">Bucles</a>
                    </li>
                    <li>
                        <a href="#item16">Funciones</a>
                    </li>
                    <li>
                        <a href="#item17">Funciones de flecha</a>
                    </li>
                    <li>
                        <a href="#item18">Objetos</a>
                    </li>
                    <li>
                        <a href="#item19">Propiedades del objeto</a>
                    </li>
                    <li>
                        <a href="#item20">Métodos de objetos</a>
                    </li>
                    <li>
                        <a href="#item21">Clases</a>
                    </li>
                    <li>
                        <a href="#item22">Herencia</a>
                    </li>
                    <li>
                        <a href="#item23">Programación asíncrona</a>
                    </li>
                    <li>
                        <a href="#item24">Promesas</a>
                    </li>
                    <li>
                        <a href="#item25">Async y await</a>
                    </li>
                    <li>
                        <a href="#item26">Alcance de variable</a>
                    </li>
                    
                </ul>
            </nav>
        </aside>

        
    
        <div class="articles">
            <section id="item1">
                <h1>Introducción a JavaScript</h1>
                <p>JavaScript es uno de los lenguajes de programación más populares del mundo.</p>
                <p>Usamos principalmente JavaScript para crear</p>
                <ul>
                    <li>sitios web</li>
                    <li>aplicaciones web</li>
                    <li>aplicaciones del lado del servidor que utilizan Node.js</li>
                </ul>

                <p>pero JavaScript no se limita a estas cosas, y también se puede utilizar para</p>

                <ul>
                    <li>crear aplicaciones móviles usando herramientas como React Native</li>
                    <li>crear programas para microcontroladores e internet de las cosas</li>
                    <li>crear aplicaciones de reloj inteligente</li>
                </ul>

                <p>Básicamente puede hacer cualquier cosa. Es tan popular que todo lo nuevo que aparezca tendrá algún tipo de integración de JavaScript en algún momento.</p>

                <p>JavaScript es un lenguaje de programación que es:</p>

                <ul>
                    <li><b>Nivel alto:</b> proporciona abstracciones que le permiten ignorar los detalles de la máquina en la que se está ejecutando. Administra la memoria automáticamente con un recolector de basura, por lo que puede concentrarse en el código en lugar de administrar la memoria como lo necesitarían otros lenguajes como C, y proporciona muchas construcciones que le permiten tratar con variables y objetos muy poderosos.</li>
                    <li><b>Dinámico:</b> a diferencia de los lenguajes de programación estáticos, un lenguaje dinámico ejecuta en tiempo de ejecución muchas de las cosas que hace un lenguaje estático en tiempo de compilación. Esto tiene pros y contras, y nos brinda características poderosas como escritura dinámica, enlace tardío, reflexión, programación funcional, alteración del tiempo de ejecución de objetos, cierres y mucho más. No se preocupe si no conoce esas cosas; las sabrá todas al final del curso.</li>
                    <li><b>Tipado dinámicamente:</b> una variable no impone un tipo. Puede reasignar cualquier tipo a una variable, por ejemplo, asignando un número entero a una variable que contiene una cadena.</li>
                    <li><b>Tipado flojo:</b> a diferencia del tipeo fuerte, los lenguajes tipeados flojamente (o débilmente) no imponen el tipo de un objeto, lo que permite más flexibilidad pero nos niega la seguridad y la verificación de tipos (algo que TypeScript, que se basa en JavaScript, proporciona)</li>
                    <li><b>Interpretado:</b> se lo conoce comúnmente como un lenguaje interpretado, lo que significa que no necesita una etapa de compilación antes de que un programa pueda ejecutarse, a diferencia de C, Java o Go, por ejemplo. En la práctica, los navegadores compilan JavaScript antes de ejecutarlo, por razones de rendimiento, pero esto es transparente para usted: no hay ningún paso adicional involucrado.</li>
                    <li><b>Multi-paradigma:</b> el lenguaje no impone ningún paradigma de programación en particular, a diferencia de Java, por ejemplo, que fuerza el uso de programación orientada a objetos, o C que fuerza la programación imperativa. Puede escribir JavaScript usando un paradigma orientado a objetos, usando prototipos y la nueva sintaxis de clases (a partir de ES6). Puede escribir JavaScript en un estilo de programación funcional, con sus funciones de primera clase, o incluso en un estilo imperativo (similar a C).</li>
                </ul>

                <p>En esta pequeña introducción quiero contaros 5 conceptos:</p>    

                <ul>
                    <li>espacio en blanco</li>
                    <li>sensibilidad a mayúsculas y minúsculas</li>
                    <li>literales</li>
                    <li>identificadores</li>
                    <li>comentarios</li>
                </ul>

                <h3>Espacio en blanco</h3>
                <p>JavaScript no considera los espacios en blanco significativos. Los espacios y los saltos de línea se pueden agregar de la forma que desee, al menos en teoría</p>
                <p>En la práctica, lo más probable es que mantenga un estilo bien definido y se adhiera a lo que la gente usa comúnmente, y lo hará cumplir con un linter o una herramienta de estilo como Prettier.                </p>
                <p>Por ejemplo, siempre uso 2 caracteres de espacio para cada sangría.</p>

                <h3>Distingue mayúsculas y minúsculas</h3>
                <p>JavaScript distingue entre mayúsculas y minúsculas. Una variable nombrada somethinges diferente a Something.</p>
                <p>Lo mismo ocurre con cualquier identificador.</p>

                <h3>Literales</h3>
                <p>Definimos literal como un valor que está escrito en el código fuente, por ejemplo, un número, una cadena, un booleano o también construcciones más avanzadas, como Object Literals o Array Literals:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">5
'Test'
true
['a', 'b']
{color: 'red', shape: 'Rectangle'}
</code></pre></div>
                </div>

                <h3>Identificadores</h3>
                <p>Un identificador es una secuencia de caracteres que se puede utilizar para identificar una variable, una función o un objeto. Puede comenzar con una letra, el signo de dólar $o un guión bajo _, y puede contener dígitos. Con Unicode, una letra puede ser cualquier carácter permitido, por ejemplo, ¿un emoji ?.</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">Test
test
TEST
_test
Test1
$test</code></pre></div>
                </div>

                <p>El signo de dólar se usa comúnmente para hacer referencia a elementos DOM.</p>

                <p>Algunos nombres están reservados para uso interno de JavaScript y no podemos usarlos como identificadores.</p>
            
                <h3>Comentarios</h3>
                <p>Los comentarios son una de las partes más importantes de cualquier programa, en cualquier lenguaje de programación. Son importantes porque nos permiten anotar el código y agregar información importante que de otro modo no estaría disponible para otras personas (o para nosotros) que lean el código.</p>
                <p>En JavaScript, podemos escribir un comentario en una sola línea usando //. Todo lo que //sigue no es considerado código por el intérprete de JavaScript.</p>
                <p>Me gusta esto:</p>
            
                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">// a comment
true //another comment</code></pre></div>
                </div>
            
                <p>Otro tipo de comentario es un comentario de varias líneas. Comienza con /*y termina con */.</p>
            
                <p>Todo lo que hay en el medio no se considera código:</p>
            
                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">/* some kind
of 
comment 

*/</code></pre></div>
                </div>
               
                
            </section>  


            <section id="item2">
                <h1>Historia</h1>
                <p>Creado en 1995, JavaScript ha recorrido un largo camino desde sus humildes comienzos.</p>
                <p>Fue el primer lenguaje de scripting que fue soportado de forma nativa por navegadores web, y gracias a esto obtuvo una ventaja competitiva sobre cualquier otro lenguaje y hoy sigue siendo el único lenguaje de scripting que podemos usar para construir aplicaciones web.</p>
                <p>Existen otros lenguajes, pero todos deben compilarse en JavaScript, o más recientemente en WebAssembly, pero esta es otra historia.</p>
                <p>Al principio, JavaScript no era tan poderoso como lo es hoy, y se usaba principalmente para animaciones sofisticadas y la maravilla conocida en ese momento como HTML dinámico.</p>
                <p>Con las crecientes necesidades que demandaba (y sigue demandando) la plataforma web, JavaScript también tenía la responsabilidad de crecer, para adaptarse a las necesidades de uno de los ecosistemas más utilizados del mundo.</p>
                <p>JavaScript también se usa ahora ampliamente fuera del navegador. El auge de Node.js en los últimos años desbloqueó el desarrollo de backend, que alguna vez fue el dominio de Java, Ruby, Python, PHP y los lenguajes del lado del servidor más tradicionales.</p>
                <p>JavaScript es ahora también el lenguaje que impulsa las bases de datos y muchas más aplicaciones, e incluso es posible desarrollar aplicaciones integradas, aplicaciones móviles, aplicaciones de TV y mucho más. Lo que comenzó como un pequeño idioma dentro del navegador es ahora el idioma más popular del mundo.</p>
            </section>

            <section id="item3">
                <h1>Vanilla JS</h1>
                <p>A veces es difícil separar JavaScript de las características del entorno en el que se utiliza.</p>
                <p>Por ejemplo, la línea console.log() que puede encontrar en muchos ejemplos de código no es JavaScript. En cambio, es parte de la amplia biblioteca de API que se nos proporciona en el navegador.</p>
                <p>De la misma manera, en el servidor a veces puede ser difícil separar las características del lenguaje JavaScript de las API proporcionadas por Node.js.</p>
                <p>¿React o Vue proporciona una función en particular? ¿O es "JavaScript simple" o "JavaScript vainilla" como se le llama a menudo?</p>
                <p>En este libro hablo de JavaScript, el lenguaje.</p>
                <p>Sin complicar tu proceso de aprendizaje con cosas que están fuera de él y provistas por ecosistemas externos.</p>
</section>

            <section id="item4">
                <h1>Punto y coma</h1>
                <p>Cada línea en un programa JavaScript se termina opcionalmente con punto y coma.</p>
                <p>Dije opcionalmente, porque el intérprete de JavaScript es lo suficientemente inteligente como para introducir punto y coma.</p>
                <p>En la mayoría de los casos, puede omitir el punto y coma de sus programas sin siquiera pensar en ello.</p>
                <p>Este hecho es muy controvertido. Algunos desarrolladores siempre usarán punto y coma, otros nunca usarán punto y coma, y ​​siempre encontrará código que usa punto y coma y código que no.</p>
                <p>Mi preferencia personal es evitar el punto y coma, por lo que mis ejemplos en el libro no los incluirán.</p>
                
            </section>

            <section id="item5">
                <h1>Valores</h1>
                <p>Una cadena hello es un valor .</p>
                <p>Un número como 12es un valor .</p>
                <p>hello y 12 son valores. stringy numberson los tipos de esos valores.</p>
                <p>El tipo es el tipo de valor, su categoría. Tenemos muchos tipos diferentes de JavaScript, y hablaremos de ellos en detalle más adelante. Cada tipo tiene sus propias características.</p>
                <p>Cuando necesitamos tener una referencia a un valor, lo asignamos a una variable.</p>
                <p>La variable puede tener un nombre, y el valor es lo que está almacenado en una variable, por lo que luego podemos acceder a ese valor a través del nombre de la variable.</p>
                
            </section>

            <section id="item6">
                <h1>Variables</h1>
           
                <p>Una variable es un valor asignado a un identificador, por lo que puede hacer referencia a él y usarlo más adelante en el programa.</p>
           
                <p>Esto se debe a que JavaScript está escrito de manera imprecisa , un concepto del que escuchará con frecuencia.</p>
           
                <p>Se debe declarar una variable antes de poder usarla.</p>
                <p>Tenemos 2 formas principales de declarar variables. El primero es usar const:</p>
                
                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const a = 0
</code></pre></div>
                </div>
           
                <p>La segunda forma es usar let:</p>
           
                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">let a = 0
</code></pre></div>
                </div>
                
                <h3>¿Cual es la diferencia?</h3>
                <p>const define una referencia constante a un valor. Esto significa que la referencia no se puede cambiar. No puede reasignarle un nuevo valor.</p>
                <p>Usando letpuedes asignarle un nuevo valor.</p>
                <p>Por ejemplo, no puede hacer esto:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const a = 0
a = 1</code></pre></div>
                </div>

                <p>Porque obtendrá un error: TypeError: Assignment to constant variable..</p>
                <p>Por otro lado, puedes hacerlo usando let:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">let a = 0
a = 1</code></pre></div>
                </div>

                <p>const no significa "constante" en la forma en que otros lenguajes como C significan. En particular, no significa que el valor no pueda cambiar, significa que no se puede reasignar. Si la variable apunta a un objeto o una matriz (veremos más sobre objetos y matrices más adelante), el contenido del objeto o la matriz puede cambiar libremente.</p>
                <p>const las variables deben inicializarse en el momento de la declaración:</p>
                
                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const a = 0
</code></pre></div>
                </div>

                <p>pero los letvalores se pueden inicializar más tarde:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">let a
a = 0</code></pre></div>
                </div>

                <p>Puede declarar varias variables a la vez en la misma declaración:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const a = 1, b = 2
let c = 1, d = 2</code></pre></div>
                </div>

                <p>Pero no puede volver a declarar la misma variable más de una vez:</p> 

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">let a = 1
let a = 2</code></pre></div>
                </div>

                <p>o obtendría un error de "declaración duplicada".</p>

                <p>Mi consejo es que use siempre consty solo use letcuando sepa que necesitará reasignar un valor a esa variable. ¿Por qué? Porque cuanto menos poder tenga nuestro código, mejor. Si sabemos que un valor no se puede reasignar, es una fuente menos de errores.</p>
                <p>Ahora que vimos cómo trabajar con consty let, quiero mencionar var.</p>
                <p>Hasta 2015, varera la única forma en que podíamos declarar una variable en JavaScript. Hoy en día, una base de código moderna probablemente solo usará consty let. Hay algunas diferencias fundamentales que detallo en esta publicación, pero si recién está comenzando, es posible que no le importen. Solo usa consty let.</p>
            </section>

            <section id="item7">
                <h1>Tipos</h1>
                <p>Las variables en JavaScript no tienen ningún tipo adjunto.</p>
                <p>No están tipificados.</p>
                <p>Una vez que asigna un valor con algún tipo a una variable, luego puede reasignar la variable para alojar un valor de cualquier otro tipo sin ningún problema.</p>
                <p>En JavaScript tenemos 2 tipos principales de tipos: tipos primitivos y tipos de objetos.</p>

                <h3>Tipos primitivos</h3>
                <p>Los tipos primitivos son</p>
                <ul>
                    <li>Números</li>
                    <li>Strings</li>
                    <li>Booleanos</li>
                    <li>Símbolos</li>
                </ul>

                <p>Y dos tipos especiales: null y undefined.</p>

                <h3>Tipos de objetos</h3>

                <p>Cualquier valor que no sea de un tipo primitivo (una cadena, un número, un booleano, nulo o indefinido) es un objeto.</p>
                <p>Los tipos de objetos tienen propiedades y también métodos que pueden actuar sobre esas propiedades.</p>
                <p>Hablaremos más sobre los objetos más adelante.</p>

            </section>

            <section id="item8">
                <h1>Expresiones</h1>

                <p>Una expresión es una unidad única de código JavaScript que el motor JavaScript puede evaluar y devolver un valor.</p>

                <p>Las expresiones pueden variar en complejidad.</p>

                <p>Partimos de las muy simples, llamadas expresiones primarias:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">2
0.02
'algo'
true
false
this //El alcance actual
undefined
i //donde i es una variable o una constante</code></pre></div>
                </div>

                <p>Las expresiones aritméticas son expresiones que toman una variable y un operador (más sobre operadores pronto), y dan como resultado un número:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">1 / 2
i++
i -= 2
i * 2</code></pre></div>

                <p>Las expresiones de cadena son expresiones que dan como resultado una cadena de texto:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">'Una ' + 'cadena de texto'
</code></pre></div>

                <p>Las expresiones lógicas hacen uso de operadores lógicos y se resuelven en un valor booleano:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">a && b
a || b
!a</code></pre></div>


                <p>Las expresiones más avanzadas involucran objetos, funciones y matrices, y las presentaré más adelante.</p>

                        
            </section>

            <section id="item9">
                <h1>Operadores</h1>
                <p>Los operadores le permiten obtener dos expresiones simples y combinarlas para formar una expresión más compleja.</p>
                <p>Podemos clasificar operadores en función de los operandos con los que trabajan. Algunos operadores trabajan con 1 operando. La mayoría trabaja con 2 operandos. Un solo operador trabaja con 3 operandos.</p>
                <p>En esta primera introducción a los operadores, presentaremos los operadores con los que probablemente esté familiarizado: operadores con 2 operandos.</p>
                <p>Ya introduje uno al hablar de variables: el operador de asignación =. Usas =para asignar un valor a una variable:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">let b = 2
</code></pre></div>

                <p>Vamos a presentar ahora otro conjunto de operadores binarios con los que ya está familiarizado en matemáticas básicas.</p>

                <h3>El operador de suma (+)</h3>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const three = 1 + 2
const four = three + 1</code></pre></div>

                <p>El operador + también realiza una concatenación de cadenas si usa cadenas, así que preste atención:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const tres = 1 + 2
tres + 1 // 4
'tres' + 1 // tres1</code></pre></div>

                <h3>El operador de resta (-)</h3>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const dos = 4 - 2
</code></pre></div>

                <h3>El operador de división (/)</h3>
                <p>Devuelve el cociente del primer operador y el segundo:</p>
                
                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const resultado = 20 / 5 //resultado === 4
const resultado = 20 / 7 //resultado === 2.857142857142857</code></pre></div>

                <p>Si divide por cero, JavaScript no genera ningún error pero devuelve el valor Infinity (o si el valor -Infinity es negativo).</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">1 / 0 //Infinity
-1 / 0 //-Infinity</code></pre></div> 

                <h3>El operador restante (%)</h3>
                <p>El resto es un cálculo muy útil en muchos casos de uso:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const resultado = 20 % 5 //resultado === 0
const resultado = 20 % 7 //resultado === 6</code></pre></div> 

                <p>Un resto por cero es siempre NaN, un valor especial que significa "No es un número":</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">1 % 0 //NaN
-1 % 0 //NaN</code></pre></div>            

                <h3>El operador de multiplicación (*)</h3>
                <p>Multiplica dos números</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">1 * 2 //2
-1 * 2 //-2</code></pre></div>          

                <h3>El operador de exponenciación (**)</h3>
                <p>Eleva el primer operando a la potencia del segundo operando</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">1 ** 2 //1
2 ** 1 //2
2 ** 2 //4
2 ** 8 //256
8 ** 2 //64</code></pre></div>  


            </section>

            <section id="item10">
                <h1>Reglas de precedencia</h1>

                <p>Cada declaración compleja con múltiples operadores en la misma línea presentará problemas de precedencia.</p>
                <p>Toma este ejemplo:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">let a = 1 * 2 + 5 / 2 % 2
</code></pre></div> 

                <p>El resultado es 2,5, pero ¿por qué?</p>
                <p>¿Qué operaciones se ejecutan primero y cuáles deben esperar?</p>

                <p>Algunas operaciones tienen más precedencia que otras. Las reglas de precedencia se enumeran en esta tabla:</p>

                <table>
                    <tr>
                        <th>Operador</th>
                        <th>Descripción</th>
                    </tr>
                    <tr>
                        <td>* / %</td>
                        <td>multiplicación / división</td>
                    </tr>
                    <tr>
                        <td>+ -</td>
                        <td>suma resta</td>
                    </tr>
                    <tr>
                        <td>=</td>
                        <td>asignación</td>
                    </tr>
                </table>
                
                <p>Las operaciones en el mismo nivel (como +y -) se ejecutan en el orden en que se encuentran, de izquierda a derecha.</p>

                <p>Siguiendo estas reglas, la operación anterior se puede resolver de esta manera:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">let a = 1 * 2 + 5 / 2 % 2
let a = 2 + 5 / 2 % 2
let a = 2 + 2.5 % 2
let a = 2 + 0.5
let a = 2.5</code></pre></div>
                
            </section>

            <section id="item11">
                <h1>Operadores de comparación</h1>
                <p>Después de los operadores matemáticos y de asignación, el tercer conjunto de operadores que quiero presentar son los operadores condicionales.</p>
                <p>Puede utilizar los siguientes operadores para comparar dos números o dos cadenas.</p>
                <p>Los operadores de comparación siempre devuelven un booleano, un valor que es trueo false).</p>
                <p>Estos son operadores de comparación de desigualdad:</p>

                <ul>
                    <li>< significa "menor que"</li>
                    <li><= significa "menor o igual que"</li>
                    <li>> significa "mayor que"</li>
                    <li>>= significa "mayor o igual que"</li>
                </ul>

                <h4>Ejemplo:</h4>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">let a = 2
a >= 1 //true</code></pre></div>       

                <p>Además de esos, tenemos 4 operadores de igualdad . Aceptan dos valores y devuelven un booleano:</p>

                <ul>
                    <li>=== controles de igualdad</li>
                    <li>!== verifica la desigualdad</li>
                </ul>

                <p>Tenga en cuenta que también tenemos ==y !=en JavaScript, pero recomiendo encarecidamente usar ===y !==porque pueden evitar algunos problemas sutiles.</p>
                
            </section>

            <section id="item12">
                <h1>Condicionales</h1>
                <p>Con los operadores de comparación en su lugar, podemos hablar de condicionales.</p>
                <p>Una declaración if se usa para hacer que el programa tome una ruta u otra, dependiendo del resultado de la evaluación de una expresión.</p>
                <p>Este es el ejemplo más simple, que siempre se ejecuta:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">if (true) {
  //hacer algo
}</code></pre></div>       

            <p>por el contrario, esto nunca se ejecuta:</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">if (false) {
  //hacer algo (? nunca ?)
}</code></pre></div>  

            <p>El condicional verifica la expresión que le pasa en busca de un valor verdadero o falso. Si pasa un número, siempre se evalúa como verdadero a menos que sea 0. Si pasa una cadena, siempre se evalúa como verdadero a menos que sea una cadena vacía. Esas son reglas generales de conversión de tipos a un booleano.</p>
            <p>¿Notaste los tirantes rizados? Eso se llama bloque y se usa para agrupar una lista de diferentes declaraciones.</p>
            <p>Se puede colocar un bloque donde pueda tener una sola declaración. Y si tiene una sola declaración para ejecutar después de los condicionales, puede omitir el bloque y simplemente escribir la declaración:</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">if (true) hacerAlgo()
</code></pre></div>  

            <p>Pero siempre me gusta usar llaves para ser más claro.</p>
            
            <p>Puede proporcionar una segunda parte a la declaración if: else.</p>

            <p>Adjunta una declaración que se ejecutará si la condición if es falsa:</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">if (true) {
  //hacer algo
} else {
  //hacer algo más
}</code></pre></div>  

            <p>Dado que elseacepta una declaración, puede anidar otra declaración if / else dentro de ella:</p>


            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">if (a === true) {
  //hacer algo
} else if (b === true) {
  //hacer algo más
} else {
  //fallback
}</code></pre></div> 

            </section>

            <section id="item13">
                <h1>Arreglos</h1>

                <p>Un arreglo es una colección de elementos.</p>

                <p>Los arreglos en JavaScript no son un tipo en sí mismas.</p>

                <p>Los arreglos son objetos.</p>

                <p>Podemos inicializar un arreglo vacío de estas 2 formas diferentes:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const a = []
const a = Array()</code></pre></div>

                <p>El primero es usar la sintaxis literal de arreglo . El segundo usa la función incorporada Array.</p>            
                <p>Puede rellenar previamente la matriz con esta sintaxis:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const a = [1, 2, 3]
const a = Array.of(1, 2, 3)</code></pre></div>             

                <p>Una matriz puede contener cualquier valor, incluso valores de diferentes tipos:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const a = [1, 'Hernando', ['a', 'b']]</code></pre></div>             

                <p>Dado que podemos agregar una matriz a una matriz, podemos crear matrices multidimensionales, que tienen aplicaciones muy útiles (por ejemplo, una matriz):</p>       

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const arreglo = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
]

arreglo[0][0] //1
arreglo[2][0] //7</code></pre></div>        

            <p>Puede acceder a cualquier elemento del arreglo haciendo referencia a su índice, que comienza desde cero:</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">a[0] //1
a[1] //2
a[2] //3</code></pre></div>                 

             <p>Puede inicializar una nueva matriz con un conjunto de valores utilizando esta sintaxis, que primero inicializa una matriz de 12 elementos y llena cada elemento con el número 0:</p>           

             <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">Array(12).fill(0)</code></pre></div>  

            <p>Puede obtener la cantidad de elementos en la matriz verificando su propiedad length:</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">const a = [1, 2, 3]
a.length //3</code></pre></div>          

            <p>Tenga en cuenta que puede establecer la longitud de la matriz. Si asigna un número mayor que la capacidad actual de las matrices, no sucede nada. Si asigna un número menor, la matriz se corta en esa posición:</p>             

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">const a = [1, 2, 3]
a //[ 1, 2, 3 ]
a.length = 2
a //[ 1, 2 ]</code></pre></div>            

            <h3>Cómo agregar un elemento a un arreglo</h3>

            <p>Podemos agregar un elemento al final de un arreglo usando el método push():</p>
                
            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">a.push(4)</code></pre></div>             

            
                    
            <p>Podemos agregar un elemento al comienzo de un arreglo usando el método unshift():</p>        

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">a.unshift(0)
a.unshift(-2, -1)</code></pre></div>             

            <h3>Como eliminar un elemento de un arreglo</h3>
            <p>Podemos eliminar un elemento del final de un arreglo usando el método pop():</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">a.pop()</code></pre></div>  

            <p>Podemos eliminar un elemento del principio de una matriz usando el método shift():</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">a.shift()</code></pre></div>          

            <h3>Cómo unir dos o más arreglos</h3>        
            <p>Puede unir varios arreglos mediante concat():</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">const a = [1, 2]
const b = [3, 4]
const c = a.concat(b) //[1,2,3,4]
a //[1,2]
b //[3,4]</code></pre></div>                  

            <p>También puede usar el operador de propagación ( ...) de esta manera:</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">const a = [1, 2]
const b = [3, 4]
const c = [...a, ...b]
c //[1,2,3,4]</code></pre></div> 

            <h3>Cómo encontrar un elemento específico en el arreglo</h3>            
            <p>Puede utilizar el método find() de un arreglo:</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">a.find((elemento, indice, arreglo) => {
  //regresa true o false
})</code></pre></div> 

            <p>Devuelve el primer elemento que devuelve verdadero y lo devuelve undefinedsi no se encuentra el elemento.</p>
            <p>Una sintaxis de uso común es:</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">a.find(x => x.id === my_id)</code></pre></div> 
            
            <p>La línea anterior devolverá el primer elemento de la matriz que tiene id === my_id.</p>
            
            <p>findIndex()funciona de manera similar find(), pero devuelve el índice del primer elemento que devuelve verdadero, y si no se encuentra, devuelve undefined:</p>
            
            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">a.findIndex((elemento, indice, arreglo) => {
  //Regresa true o false
})</code></pre></div> 
            
            <p>Otro método es includes():</p>
            
            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">a.includes(value)
</code></pre></div> 
            
            <p>Devuelve verdadero si a contiene valor.</p>
            
            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">a.includes(value, i)
</code></pre></div> 

            <p>Devuelve verdadero si acontiene value después de la posición i.</p>
            
                </section>

            <section id="item14">
                <h1>Cadena de texto</h1>
                <p>Una cadena de texto es una secuencia de caracteres.</p>
                <p>También se puede definir como un literal de cadena, que se encierra entre comillas o comillas dobles:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">'Una cadena de texto'
"Otra cadena de texto"</code></pre></div>     

                <p>Personalmente, prefiero las comillas simples todo el tiempo y uso comillas dobles solo en HTML para definir atributos.</p>
                <p>Asignas un valor de cadena a una variable como esta:</p>
                        
                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const nombre = 'Hernando'
</code></pre></div>  

                <p>Puede determinar la longitud de una cadena usando la lengthpropiedad de la misma:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">'Hernando'.length //8
const nombre = 'Hernando'
nombre.length //8</code></pre></div> 

                <p>Esta es una cadena vacía: ''. Su propiedad de longitud es 0:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">''.length //0
</code></pre></div>             

                <p>Se pueden unir dos cadenas mediante el operador +:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">"Una " + "cadena de texto"
</code></pre></div>  

                <p>Puede utilizar el operador + para interpolar variables:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const nombre = 'Hernando'
"Mi nombre es " + nombre //Mi nombre es Hernando</code></pre></div>  

                <p>Otra forma de definir cadenas es usar literales de plantilla, definidos dentro de comillas invertidas. Son especialmente útiles para simplificar mucho las cadenas de varias líneas. Con comillas simples o dobles, no puede definir una cadena de varias líneas fácilmente; necesitaría usar caracteres de escape.</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const cadenaDeTexto = `¡Hey,
esta

cadena de texto
es asombrosa!`</code></pre></div>            

            <p>Los literales de plantilla también son excelentes porque proporcionan una manera fácil de interpolar variables y expresiones en cadenas.</p>
            
            <p>Lo hace utilizando la sintaxis ${...} :</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">const var = 'prueba'
const cadenaDeTexto = `algo ${var}` 
//Alguna prueba</code></pre></div>   

            <p>dentro de ${} puedes agregar cualquier cosa, incluso expresiones:</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">const cadenaDeTexto = `algo ${1 + 2 + 3}`
const cadenaDeTexto2 = `algo 
  ${foo() ? 'x' : 'y'}`</code></pre></div> 

            </section>

            <section id="item15">
                <h1>Bucles</h1>

                <p>Los bucles son una de las principales estructuras de control de JavaScript.</p>
                <p>Con un bucle podemos automatizar y repetir un bloque de código cuantas veces queramos que se ejecute, incluso de forma indefinida.</p>
                <p>JavaScript proporciona muchas formas de iterar a través de bucles.</p>
                <p>Quiero enfocarme en 3 formas:</p>

                <ul>
                    <li>Bucle while</li>
                    <li>Bucle for</li>
                    <li>Bucle for...of</li>
                </ul>

                <h3>while</h3>
                <p>El bucle while es la estructura de bucle más simple que nos proporciona JavaScript.</p>
                <p>Agregamos una condición después de la whilepalabra clave y proporcionamos un bloque que se ejecuta hasta que la condición se evalúa como true.</p>

                <h4>Ejemplo:</h4>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const lista = ['a', 'b', 'c']
let i = 0
while (i < lista.length) {
  console.log(list[i]) //valor
  console.log(i) //indice
  i = i + 1
}</code></pre></div> 

                <p>Puede interrumpir un whilebucle usando la breakpalabra clave, así:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">while(true) {
  if (algoEsVerdadero) break
}</code></pre></div> 

                <p>y si decide que en medio de un ciclo desea omitir la iteración actual, puede saltar a la siguiente iteración usando continue:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">while (true) {
  if (algoEsVerdadero) continue

  //hacer algo más...
}</code></pre></div> 

            <p>Muy similar a while, tenemos do..whilebucles. Es básicamente lo mismo que while, excepto que la condición se evalúa después de que se ejecuta el bloque de código.</p>

            <h4>Ejemplo:</h4>

            <p>Esto significa que el bloque siempre se ejecuta al menos una vez.</p>

            <h4>Ejemplo:</h4>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">const lista = ['a', 'b', 'c']
let i = 0
do {
  console.log(lista[i]) //valor
  console.log(i) //indice
  i = i + 1
} while (i < lista.length)</code></pre></div> 

            <h3>for</h3>

            <p>La segunda estructura de bucle muy importante en JavaScript es el bucle for.</p>

            <p>Usamos la palabra clave for y pasamos un conjunto de 3 instrucciones: la inicialización, la condición y la parte de incremento.</p>


            <h4>Ejemplo:</h4>
                
            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">const lista = ['a', 'b', 'c']

for (let i = 0; i < lista.length; i++) {
  console.log(lista[i]) //valor
  console.log(i) //indice
}</code></pre></div> 

            <p>Al igual que con los bucles while, puede interrumpir un bucle for usando breaky puede avanzar rápidamente a la siguiente iteración de un bucle for usando continue.</p>        


            <h3>for...of</h3>

            <p>Este ciclo es relativamente reciente (introducido en 2015) y es una versión simplificada del ciclo for:</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">const lista = ['a', 'b', 'c']

for (const valor of lista) {
  console.log(valor) //valor
}}</code></pre></div> 

            </section>

            <section id="item16">
                <h1>Funciones</h1>
                <p>En cualquier programa JavaScript moderadamente complejo, todo sucede dentro de las funciones.</p>
                <p>Las funciones son una parte esencial de JavaScript.</p>
                <p>¿Qué es una función?</p>
                <p>Una función es un bloque de código autónomo.</p>
                <p>Aquí hay una declaración de función:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">function getData() {
  // dHacer algo
}</code></pre></div>     

            <p>Una función se puede ejecutar en cualquier momento que desee invocándola, así:</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">obtenerDatos()
</code></pre></div> 

            <p>Una función puede tener uno o más argumentos:</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">function obtenerDatos() {
  //Hacer algo
}

function obtenerDatos(color) {
  //Hacer algo
}

function obtenerDatos(color, edad) {
  //Hacer algo
}
</code></pre></div> 

            <p>Cuando podemos pasar un argumento, invocamos la función pasando parámetros:</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">function obtenerDatos(color, edad) {
  //Hacer algo
}

obtenerDatos('verde', 24)
obtenerDatos('black')</code></pre></div> 

            <p>Podemos verificar si un valor no está indefinido usando este condicional:</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">function obtenerDatos(color, edad) {
  //Hacer algo
  if (typeof edad !== 'undefined') {
    //...
  }
}</code></pre></div> 

            <p>typeof es un operador unario que nos permite comprobar el tipo de variable.</p>
            <p>También puede verificar de esta manera:</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">function obtenerDatos(color, edad) {
  //Hacer algo
  if (edad) {
    //...
  }
}</code></pre></div> 

            <p>Aunque el condicional también será verdadero si edad es null, o 0 una cadena vacía.</p>

            <p>Puede tener valores predeterminados para los parámetros, en caso de que no se pasen:</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">function obtenerDatos(color = 'negro', edad = 25) {
  //Hacer algo
}</code></pre></div>

            <p>Puede pasar cualquier valor como parámetro: números, cadenas, valores booleanos, matrices, objetos y también funciones.</p>

            <p>Una función tiene un valor de retorno. De forma predeterminada, una función regresa undefined, a menos que agregue una returnpalabra clave con un valor:</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">function obtenerDatos() {
  // Hacer algo
  return '¡Hola!'
}</code></pre></div>

            <p>Podemos asignar este valor de retorno a una variable cuando invocamos la función:</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">function obtenerDatos() {
  // Hacer algo
  return '¡Hola!'
}

let resultado = obtenerDatos()</code></pre></div>    

            <p>resultado ahora contiene una cadena de texto con el valor ¡Hola!.</p>

            <p>Solo puede devolver un valor.</p>

            <p>Para devolver varios valores, puedes devolver un objeto o un arreglo, como este:</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">function obtenerDatos() {
  return ['Hernando', 25]
}

let [nombre, edad] = getData()</code></pre></div> 

            <p>Las funciones se pueden definir dentro de otras funciones:</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">const obtenerDatos = () => {
  const hacerAlgo = () => {}
  hacerAlgo()
  return 'Prueba'
}</code></pre></div> 

            <p>La función anidada no se puede llamar desde el exterior de la función adjunta.</p>
            <p>También puede devolver una función desde una función.</p>

            </section>

            <section id="item17">
                <h1>Funciones de flecha</h1>

                <p>Las funciones de flecha son una introducción reciente a JavaScript.</p>

                <p>Se utilizan con mucha frecuencia en lugar de funciones "regulares", las que describí en el capítulo anterior. Encontrará ambas formas utilizadas en todas partes.</p>

                <p>Visualmente, te permiten escribir funciones con una sintaxis más corta, desde:</p>


                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">function obtenerDatos() {
  //...
}</code></pre></div> 

                <p>Para</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">() => {
  //...
}</code></pre></div> 

                <p>Pero ... observe que no tenemos un nombre aquí.</p>
                <p>Las funciones de flecha son anónimas. Debemos asignarlos a una variable.</p>
                <p>Podemos asignar una función regular a una variable, así:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">let obtenerDatos = function obtenerDatos() {
  //...
}</code></pre></div> 

                <p>Cuando lo hacemos, podemos eliminar el nombre de la función:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">let obtenerDatos = function() {
  //...
}</code></pre></div> 


                <p>e invocar la función usando el nombre de la variable:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">let obtenerDatos = function() {
  //...
}
obtenerDatos()</code></pre></div> 

                <p>Eso es lo mismo que hacemos con las funciones de flecha:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">let obtenerDatos = function() {
  //...
}
obtenerDatos()</code></pre></div>

                <p>Si el cuerpo de la función contiene solo una declaración, puede omitir los paréntesis y escribir todo en una sola línea:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const obtenerDatos = () => console.log('¡Hello!')
</code></pre></div>

                <p>Los parámetros se pasan entre paréntesis:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const obtenerDatos = (parametro1, parametro2) => 
  console.log(parametro1, parametro2)</code></pre></div>

                <p>Si tiene un parámetro (y solo uno), puede omitir los paréntesis por completo:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const obtenerDatos = parametro => console.log(parametro)
</code></pre></div>             

                <p>Las funciones de flecha le permiten tener un retorno implícito: los valores se devuelven sin tener que usar la palabra clave return.</p>

                <p>Funciona cuando hay una declaración de una línea en el cuerpo de la función:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const obtenerDatos = () => 'prueba'

obtenerDatos() //'prueba'</code></pre></div>
                
                <p>Al igual que con las funciones regulares, podemos tener valores predeterminados para los parámetros en caso de que no se pasen:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const obtenerDatos (color = 'negro', 
                 edad = 2) => {
  //Hacer algo
}</code></pre></div>

                <p>Y al igual que las funciones regulares, solo podemos devolver un valor.</p>

                <p>Las funciones de flecha también pueden contener otras funciones de flecha, o incluso funciones regulares.</p>

                <p>Los dos tipos de funciones son muy similares, por lo que podría preguntarse por qué se introdujeron las funciones de flecha. La gran diferencia con las funciones regulares es cuando se utilizan como métodos de objeto. Esto es algo que veremos pronto.</p>


            </section>

            <section id="item18">
                <h1>Objetos</h1>
                <p>Cualquier valor que no sea de un tipo primitivo (una cadena de texto, un número, un booleano, un símbolo, nulo o indefinido) es un objeto.</p>
                <p>Así es como definimos un objeto:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const carro = {

}</code></pre></div>

                <p>Esta es la sintaxis literal del objeto, que es una de las cosas más bonitas de JavaScript.</p>
                <p>También puede utilizar la sintaxis new Object:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const carro = new Object()
</code></pre></div>

                <p>Otra sintaxis es usar Object.create():</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const carro = Object.create()
</code></pre></div>

                <p>También puede inicializar un objeto usando la newpalabra clave antes de una función con una letra mayúscula. Esta función sirve como constructor para ese objeto. Allí, podemos inicializar los argumentos que recibimos como parámetros, para configurar el estado inicial del objeto:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">function Carro(marca, modelo) {
  this.marca = marca
  this.modelo = modelo
}</code></pre></div>

                <p>Inicializamos un nuevo objeto usando:</p>
                
                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const miCarro = new Carro('Ford', 'Fiesta')
miCarro.marca //'Ford'
miCarro.modelo //'Fiesta'</code></pre></div>


                <p>Los objetos siempre se pasan por referencia.</p>

                <p>Si asigna a una variable el mismo valor que otra, si es un tipo primitivo como un número o una cadena, se pasan por valor:</p>

                <p>Toma este ejemplo:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">let edad = 36
let miEdad = edad
miEdad = 37
edad //36</code></pre></div>     


                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const carro = {
  color: 'azul'
}
const otroCarro = carro
otroCarro.color = 'Amarillo'
carro.color //'Amarillo'</code></pre></div> 

            <p>Incluso los arreglos o funciones son, bajo el capó, objetos, por lo que es muy importante comprender cómo funcionan.</p>



            </section>

            <section id="item19">
                <h1>Propiedades del objeto</h1>
                
                <p>Los objetos tienen propiedades , que están compuestas por una etiqueta asociada con un valor.</p>
                <p>El valor de una propiedad puede ser de cualquier tipo, lo que significa que puede ser una matriz, una función e incluso un objeto, ya que los objetos pueden anidar otros objetos.</p>
                <p>Esta es la sintaxis literal de objeto que vimos en el capítulo anterior:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const carro = {

}</code></pre></div>

                <p>Podemos definir una propiedad color de esta manera:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const carro = {
  color: 'azul'
}</code></pre></div>

            <p>Aquí tenemos un objeto carro con una propiedad nombrada color, con valor azul.</p>

            <p>Las etiquetas pueden ser cualquier cadena, pero tenga cuidado con los caracteres especiales: si quisiera incluir un carácter no válido como nombre de variable en el nombre de la propiedad, habría tenido que usar comillas a su alrededor:</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">const carro = {
  color: 'azul',
  'El color': 'azul'
}</code></pre></div>    

            <p>Los caracteres de nombre de variable no válidos incluyen espacios, guiones y otros caracteres especiales.</p>
            <p>Como puede ver, cuando tenemos varias propiedades, separamos cada propiedad con una coma.</p>
            <p>Podemos recuperar el valor de una propiedad usando 2 sintaxis diferentes.</p>
            <p>La primera es la notación de puntos:</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">carro.color //'blue'
</code></pre></div> 

            <p>El segundo (que es el único que podemos usar para propiedades con nombres inválidos), es usar corchetes:</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">carro['El color'] //'azul'
</code></pre></div> 

            <p>Si accede a una propiedad inexistente, obtendrá el valor undefined:</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">carro.marca //undefined
</code></pre></div> 

            <p>Como se mencionó anteriormente, los objetos pueden tener objetos anidados como propiedades:</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">const carro = {
  marca: {
    nombre: 'Ford'
  },
  color: 'azul'
}</code></pre></div> 

            <p>En este ejemplo, puede acceder al nombre de la marca utilizando</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">carro.marca.nombre
</code></pre></div>

            <p>o</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">carro['marca']['nombre']
</code></pre></div>

            <p>Puede establecer el valor de una propiedad cuando define el objeto.</p>

            <p>Pero siempre puedes actualizarlo más adelante:</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">const carro = {
  color: 'azul'
}

carro.color = 'Amarillo'
carro['color'] = 'Rojo'</code></pre></div>

            <p>Y también puede agregar nuevas propiedades a un objeto:</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">carro.modelo = 'Fiesta'

carro.modelo //'Fiesta'</code></pre></div>

            <p>Dado el objeto</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">const carro = {
  color: 'azul',
  brand: 'Ford'
}</code></pre></div>            

            <p>puede eliminar una propiedad de este objeto usando</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">delete carro.marca
</code></pre></div>  

            </section>

            <section id="item20">
                <h1>Métodos de objeto</h1>
                <p>Hablé de funciones en un capítulo anterior.</p>
                <p>Las funciones se pueden asignar a una propiedad de función y, en este caso, se denominan métodos.</p>    
                <p>En este ejemplo, la propiedad start tiene una función asignada y podemos invocarla usando la sintaxis de puntos que usamos para las propiedades, con el paréntesis al final:</p>


                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const carro = {
  marca: 'Ford',
  modelo: 'Fiesta',
  encender: function() {
    console.log('¡Encendido!')
  }
}

carro.encender()</code></pre></div>    

              <p>Dentro de un método definido usando una sintaxis function(){} tenemos acceso a la instancia del objeto haciendo referencia this.</p>  

              <p>En el siguiente ejemplo, tenemos acceso a el valor marca utilizando las propiedades this.brand y this.model:</p>

              <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">const carro = {
  marca: 'Ford',
  modelo: 'Fiesta',
  encender: function() {
    console.log(`Started 
      ${this.marca} ${this.modelo}`)
  }
}

carro.encender()</code></pre></div> 

            <p>Es importante tener en cuenta esta distinción entre funciones regulares y funciones de flecha; no tenemos acceso thissi usamos una función de flecha:</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">const carro = {
  marca: 'Ford',
  modelo: 'Fiesta',
  encender: () => {
    console.log(`Encendido 
      ${this.marca} ${this.modelo}`) //No va a funcionar
  }
}

carro.encender()</code></pre></div> 

            <p>Esto se debe a que las funciones de flecha no están vinculadas al objeto.</p>

            <p>Esta es la razón por la que las funciones regulares se utilizan a menudo como métodos de objeto.</p>

            <p>Los métodos pueden aceptar parámetros, como funciones regulares:</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">const carro = {
  marca: 'Ford',
  modelo: 'Fiesta',
  irA: function(destino) {
    console.log(`Yendo a ${destino}`)
  }
}

carro.irA('Roma')</code></pre></div> 

            </section>

            <section id="item21">
                <h1>Clases</h1>

                <p>Hablamos de objetos, que son una de las partes más interesantes de JavaScript.</p>

                <p>En este capítulo subiremos un nivel introduciendo clases.</p>
    
                <p>¿Qué son las clases? Son una forma de definir un patrón común para varios objetos.</p>
                
                <p>Tomemos un objeto persona:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const persona = {
  nombre: 'Hernando'
}</code></pre></div> 

                <p>Podemos crear una clase llamada Persona(tenga en cuenta la capital P, una convención cuando se usan clases), que tiene una propiedad nombre:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">class Persona {
  nombre
}
</code></pre></div> 

                <p>Ahora desde esta clase, inicializamos un objeto Hernando como este:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const hernando = new Person()
</code></pre></div> 

                <p>Hernando llama una instancia de la clase Persona.</p>

                <p>Podemos establecer el valor de la propiedad nombre:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">hernando.nombre = 'Hernando'
</code></pre></div> 

                <p>Y podemos acceder a él usando</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">hernando.nombre</code></pre></div>

                <p>Como hacemos con las propiedades de los objetos.</p>

                <p>Las clases pueden contener propiedades, me gusta namey métodos.</p>

                <p>Los métodos se definen de esta manera:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">class Persona {
  hola() {
    return 'Hola, yo soy Hernando'
  }
}</code></pre></div>

                <p>Y podemos invocar métodos en una instancia de la clase:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">class Persona {
  hola() {
    return 'Hola, yo soy Hernando'
  }
}
const flavio = new Person()
flavio.hello()</code></pre></div>    

                <p>Hay un método especial llamado constructor() que podemos usar para inicializar las propiedades de la clase cuando creamos una nueva instancia de objeto.</p>

                <p>Funciona así:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">class Persona {
  constructor(nombre) {
    this.nombre = nombre
  }

  hello() {
    return 'Hola, soy ' + this.nombre + '.'
  }
}</code></pre></div> 

                <p>Tenga en cuenta cómo usamos this para acceder a la instancia del objeto.</p>

                <p>Ahora podemos crear una instancia de un nuevo objeto de la clase, pasar una cadena y, cuando llamemos hola, obtendremos un mensaje personalizado</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const hernando = new Persona('Hernando')
hernando.hola() //'Hola, soy Hernando.'</code></pre></div>     

                <p>Cuando se inicializa el objeto, constructorse llama al método con los parámetros pasados.</p>
                <p>Normalmente, los métodos se definen en la instancia del objeto, no en la clase.</p>           
                <p>Puede definir un método staticpara permitir que se ejecute en la clase en su lugar:</p>
                    
                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">class Persona {
  static saludoGenerico() {
    return 'Hola'
  }
}

Persona.saludoGenerico() //Hola</code></pre></div>             

            <p>Esto es muy útil, a veces.</p>

            </section>

            <section id="item22">
                <h1>Herencia</h1>

                <p>Una clase puede extender otra clase y los objetos inicializados usando esa clase heredan todos los métodos de ambas clases.</p>
                <p>Supongamos que tenemos una clase Persona:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">class Persona {
  hola() {
    return 'Hola, soy una persona'
  }
}</code></pre></div> 

                <p>Podemos definir una nueva clase Programador, que se extiende Persona:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">class Programador extends Persona {

}</code></pre></div> 

            <p>Ahora, si instanciamos un nuevo objeto con la clase Programador, tiene acceso al método hello():</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">const hernando = new Programador()
hernando.hello() //'Hola, soy una persona'</code></pre></div>

            <p>Dentro de una clase secundaria, puede hacer referencia a la clase principal llamando a super():</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">class Programador extends Persona {
  hola() {
    return super.hola() + 
      '. Yo también soy un programador.'
  }
}

const hernando = new Programador()
hernando.hola()</code></pre></div>        

            <p>El programa anterior imprime Hola, soy una persona. También soy programador.</p>
            </section>

            <section id="item23">
                <h1>Programación asíncrona</h1>
                <p>La mayoría de las veces, el código JavaScript se ejecuta de forma sincrónica.</p>
                <p>Esto significa que se ejecuta una línea de código, luego se ejecuta la siguiente, y así sucesivamente.</p>
                <p>Todo es como esperas y como funciona en la mayoría de los lenguajes de programación.</p>
                <p>Sin embargo, hay ocasiones en las que no puede simplemente esperar a que se ejecute una línea de código.</p>
                <p>No puede esperar 2 segundos a que se cargue un archivo grande y detener el programa por completo.</p>
                <p>No puede simplemente esperar a que se descargue un recurso de red antes de hacer otra cosa.</p>
                <p>JavaScript resuelve este problema utilizando devoluciones de llamada.</p>
                <p>Uno de los ejemplos más simples de cómo usar devoluciones de llamada es con temporizadores. Los temporizadores no forman parte de JavaScript, pero los proporciona el navegador y Node.js. Permítanme hablar de uno de los temporizadores que tenemos: setTimeout().</p>
                <p>La setTimeout()función acepta 2 argumentos: una función y un número. El número son los milisegundos que deben pasar antes de que se ejecute la función.</p>

                <h4>Ejemplo:</h4>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">setTimeout(() => {
  // Arranca después de 2 segundos
  console.log('Dentro de la función')
}, 2000)</code></pre></div>

                <p>La función que contiene la console.log('Dentro de la función')línea se ejecutará después de 2 segundos.</p>

                <p>Si agrega un console.log('before') antes de la función y console.log('Después') después de ella:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">console.log('Antes')
setTimeout(() => {
  // Arranca después de 2 segundos
  console.log('Dentro de la función')
}, 2000)
console.log('Después')</code></pre></div>

                <p>Verá que esto sucede en su consola:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">Antes
Después
Dentro de la función</code></pre></div>
                
                <p>La función de devolución de llamada se ejecuta de forma asincrónica.</p>
                <p>Este es un patrón muy común cuando se trabaja con el sistema de archivos, la red, los eventos o el DOM en el navegador.</p>
                <p>Todas las cosas que mencioné no son JavaScript "centrales", por lo que no se explican en este manual, pero encontrará muchos ejemplos en mis otros manuales disponibles en https://hernandoabella.com .</p>
                <p>Así es como podemos implementar devoluciones de llamada en nuestro código.</p>
                <p>Definimos una función que acepta un parámetro callback, que es una función.</p>
                <p>Cuando el código está listo para invocar la devolución de llamada, lo invocamos pasando el resultado:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const hacerAlgo = callback => {
  //hacer cosas
  //hacer cosas
  const resultado = /* .. */
  callback(resultado)
}</code></pre></div>            

                <p>El código que usa esta función lo usaría así:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">hacerAlgo(resultado => {
  console.log(resultado)
})</code></pre></div>  
                
            </section>

            <section id="item24">
                <h1>Promesas</h1>
                <p>Las promesas son una forma alternativa de lidiar con el código asincrónico.</p>
                <p>Como vimos en el capítulo anterior, con las devoluciones de llamada estaríamos pasando una función a otra llamada de función que se llamaría cuando la función haya terminado de procesarse.</p>
                <p>Me gusta esto:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">hacerAlgo(resultado => {
  console.log(resultado)
})</code></pre></div>

                <p>Cuando el código hacerAlgo() termina, llama a la función recibida como parámetro:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const hacerAlgo = callback => {
  //hacer cosas
  //hacer cosas
  const resultado = /* .. */
  callback(resultado)
}</code></pre></div>

                <p>El principal problema con este enfoque es que si necesitamos usar el resultado de esta función en el resto de nuestro código, todo nuestro código debe estar anidado dentro de la devolución de llamada, y si tenemos que hacer 2-3 devoluciones de llamada ingresamos en lo que es normalmente se define como "infierno de devolución de llamada" con muchos niveles de funciones con sangría en otras funciones:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">hacerAlgo(resultado => {
  doSomethingElse(otroResultado => {
    doSomethingElseAgain(aunOtroResultado => {
      console.log(resultado)
    })
  }) 
})</code></pre></div>

                <p>Las promesas son una forma de lidiar con esto.</p>

                <p>En lugar de hacer:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">hacerAlgo(resultado => {
  console.log(resultado)
})</code></pre></div>

                <p>Llamamos a una función basada en promesas de esta manera:</p>
                
                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">hacerAlgo()
  .then(resultado => {
    console.log(resultado)
  })</code></pre></div>

                <p>Primero llamamos a la función, luego tenemos un método then() que se llama cuando finaliza la función.</p>

                <p>La sangría no importa, pero a menudo utilizará este estilo para mayor claridad.</p>

                <p>Es común detectar errores usando un método catch():</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">hacerAlgo()
  .then(resultado => {
    console.log(resultado)
  })
  .catch(error => {
    console.log(error)
  })</code></pre></div>


                <p>Ahora, para poder usar esta sintaxis, la implementación doSomething() de la función debe ser un poco especial. Debe utilizar la API de Promises.</p>
                <p>En lugar de declararlo como una función normal:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const hacerAlgo = () => {
  
}</code></pre></div>

                <p>Lo declaramos como objeto de promesa:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const hacerAlgo = new Promise()
</code></pre></div>

                <p>Y pasamos una función en el constructor Promise:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const hacerAlgo = new Promise(() => {

})</code></pre></div>

                <p>Esta función recibe 2 parámetros. La primera es una función que llamamos para resolver la promesa, la segunda es una función que llamamos para rechazar la promesa.</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const hacerAlgo = new Promise(
  (resolver, rechazar) => {
    
})</code></pre></div>

                <p>Resolver una promesa significa completarla con éxito (lo que da como resultado que se llame al método then() en lo que sea que lo use).</p>

                <p>Rechazar una promesa significa terminarla con un error (lo que resulta en llamar al catch()método en lo que sea que lo use).</p>

                <p>Así es cómo:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const hacerAlgo = new Promise(
  (resolver, rechazar) => {
    //Algo de código
    const exito = /* ... */
    if (exito) {
      resolver('ok')
    } else {
      rechazar('Este error ha ocurrido')
    }
  }
)</code></pre></div>


                <p>Podemos pasar un parámetro a las funciones de resolver y rechazar, del tipo que queramos.</p>

            </section>

            <section id="item25">
                <h1>Async y await</h1>

                <p>Las funciones asíncronas son una abstracción de promesas de nivel superior.</p>
                <p>Una función asincrónica devuelve una promesa, como en este ejemplo:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">const obtenerDatos = () => {
  return new Promise((resolver, rechazar) => {
    setTimeout(() => 
      resolver('Algunos datos'), 2000)
  })
}</code></pre></div>


            <p>Cualquier código que quiera usar esta función usará la awaitpalabra clave justo antes de la función:</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">const dato = await obtenerDatos()
</code></pre></div>

            <p>Y al hacerlo, todos los datos devueltos por la promesa se asignarán a la datavariable.</p>

            <p>En nuestro caso, los datos son la cadena de texto "algunos datos".</p>

            <p>Con una advertencia en particular: siempre que usemos la awaitpalabra clave, debemos hacerlo dentro de una función definida como async.</p>

            <p>Me gusta esto:</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">const hacerAlgo = async () => {
  const dato = await obtenerDatos()
  console.log(dato)
}</code></pre></div>

            <p>El dúo async / await nos permite tener un código más limpio y un modelo mental simple para trabajar con código asincrónico.</p>

            <p>Como puede ver en el ejemplo anterior, nuestro código parece muy simple. Compárelo con el código mediante promesas o funciones de devolución de llamada.</p>

            <p>Y este es un ejemplo muy simple, los mayores beneficios surgirán cuando el código sea mucho más complejo.</p>

            <p>Como ejemplo, así es como obtendría un recurso JSON usando la API Fetch y lo analizaría usando promesas:</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">const obtenerPrimerDatoUsuario = () => {
  // Obtener lista de usuarios
  return fetch('/usuarios.json') 
    // parse JSON
    .then(response => response.json()) 
    // Elegir el primer usuario
    .then(usuarios => usuarios[0]) 
    // Obtener los datos del usuario
    .then(usuario => 
      fetch(`/users/${usuario.name}`)) 
    // parse JSON
    .then(respuestaUsuario => response.json()) 
}

obtenerPrimerDatoUsuario()</code></pre></div>

            <p>Y aquí está la misma funcionalidad proporcionada usando await / async:</p>

            <div class="panel">
                <div class="codigo__javascript">
                    <div class="decor__bar javascript"></div>
                    <pre class="line-numbers"><code class="language-javascript">const getFirstUserData = async () => {
  // get users list
  const response = await fetch('/users.json') 
  // parse JSON
  const users = await response.json() 
  // pick first user
  const user = users[0] 
  // get user data
  const userResponse = 
    await fetch(`/users/${user.name}`)
  // parse JSON
  const userData = await user.json() 
  return userData
}

getFirstUserData()</code></pre></div>

            
            </section>

            <section id="item26">
                <h1>Alcance de variable</h1>

                <p>Cuando presenté las variables, hablé sobre el uso const, let y var.</p>
                <p>El alcance es el conjunto de variables visibles para una parte del programa.</p>
                <p>En JavaScript tenemos un alcance global, alcance de bloque y alcance de función.</p>
                <p>Si una variable se define fuera de una función o bloque, se adjunta al objeto global y tiene un alcance global, lo que significa que está disponible en todas las partes de un programa.</p>
                <p>Hay una diferencia muy importante entre var, let y const declaraciones.</p>
                <p>Una variable definida como vardentro de una función solo es visible dentro de esa función, similar a los argumentos de una función.</p>
                <p>Una variable definida como consto let por otro lado solo es visible dentro del bloque donde está definida.</p>
                <p>Un bloque es un conjunto de instrucciones agrupadas en un par de llaves, como las que podemos encontrar dentro de una ifdeclaración, un forbucle o una función.</p>
                <p>Es importante comprender que un bloque no define un nuevo alcance para var, pero lo hace para let y const.</p>
                <p>Esto tiene implicaciones muy prácticas.</p>
                <p>Suponga que define una varvariable dentro de un if condicional en una función</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">function obtenerDatos() {
  if (true) {
    var dato = 'algun dato'
    console.log(dato) 
  }
}</code></pre></div>

                <p>Si llama a esta función, se imprimirá algun dato en la consola.</p>
                <p>Si intenta mover console.log (datos) después de if, todavía funciona:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">function obtenerDatos() {
  if (true) {
    var dato = 'algun dato'
  }
  console.log(dato) 
}</code></pre></div>

                <p>Pero si cambia var dato a let data:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">function obtenerDatos() {
  if (true) {
    let dato = 'algun dato'
  }
  console.log(dato) 
}</code></pre></div>

                <p>Usted obtendrá un error: ReferenceError: data is not defined.</p>

                <p>Esto se debe a varque la función está dentro del alcance, y aquí está sucediendo algo especial llamado izado. En resumen, varJavaScript mueve la declaración a la parte superior de la función más cercana antes de ejecutar el código. Así es como se ve la función para JS internamente, más o menos:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">function obtenerDatos() {
  var dato
  if (true) {
    dato = 'algun dato'
  }
  console.log(dato) 
}</code></pre></div>

                <p>Es por eso que también puede console.log(dato) en la parte superior de una función, incluso antes de que se declare, y obtendrá como valor undefined para esa variable:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">function obtenerDatos() {
  console.log(dato) 
  if (true) {
    var dato = 'algun dato'
  }
}</code></pre></div>

                <p>Pero si cambia a let, obtendrá un error ReferenceError: data is not defined, porque la elevación no ocurre con las declaraciones let.</p>
                <p>const sigue las mismas reglas que let: tiene ámbito de bloque.</p>
                <p>Puede ser complicado al principio, pero una vez que te des cuenta de esta diferencia, verás por qué varse considera una mala práctica hoy en día en comparación con let: tienen menos partes móviles y su alcance se limita al bloque, lo que también los hace muy buenos. como variables de ciclo porque dejan de existir después de que un ciclo ha terminado:</p>

                <div class="panel">
                    <div class="codigo__javascript">
                        <div class="decor__bar javascript"></div>
                        <pre class="line-numbers"><code class="language-javascript">function hacerIteracion() {
  for (var i = 0; i < 10; i++) {
    console.log(i)
  }
  console.log(i)
}

hacerIteracion()</code></pre></div>

                <p>Cuando salga del bucle, i será una variable válida con valor 10.</p>

                <p>Si cambia a let, cuando lo intente, console.log(i) se producirá un error ReferenceError: i is not defined.</p>

            </section>

        </div>
    </div>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="./pagination.js"></script>
    <script src="./js/script.js"></script>
</body>
</html>